# Requirements Document

## Introduction

A multi-author community blogging platform for tech enthusiasts, built with React/Next.js on the frontend and Python/Django as the backend REST API. The platform features a hacker/terminal aesthetic with dark backgrounds, monospace fonts, and neon accent colors. It supports user authentication, multi-author publishing workflows, rich text editing with code syntax highlighting, threaded comments, tag-based filtering, SEO optimization, and a dark/light mode toggle. The backend uses PostgreSQL (via Docker for local development) and serves data through a RESTful API.

## Glossary

- **Platform**: The community blogging web application as a whole, encompassing both the Next.js frontend and the Django REST API backend.
- **Frontend**: The React/Next.js client application responsible for rendering pages, handling user interactions, and managing client-side state.
- **Backend_API**: The Python/Django REST API server responsible for data persistence, business logic, authentication, and serving JSON responses to the Frontend.
- **User**: A registered person with the default role, who can read Posts, submit Comments, and like Comments. Anonymous visitors can only read public content.
- **Author**: A registered User whose Author role request has been approved by a Moderator, granting permission to create, edit, and manage blog posts in addition to all User capabilities.
- **Author_Request**: A request submitted by a User to be promoted to the Author role, which must be approved or rejected by a Moderator.
- **Post**: A blog article created by an Author, containing a title, body content (in Markdown), cover image, tags, and metadata.
- **Editor**: The rich text Markdown editing interface used by Authors to compose and edit Posts.
- **Comment**: A user-submitted text response attached to a Post, supporting threading (replies) and likes.
- **Tag**: A keyword label (e.g., #javascript, #linux, #ai) assigned to a Post for categorization and filtering.
- **Badge**: A role-based or achievement-based label displayed on an Author's profile (e.g., [TOP CONTRIBUTOR], [MODERATOR]).
- **Terminal_Theme**: The default dark visual theme featuring deep black/dark gray backgrounds (#0d0d0d, #1a1a1a), neon green (#00ff41) or electric cyan (#00e5ff) accents, monospace fonts, and CLI-inspired UI elements.
- **Light_Theme**: The alternative visual theme featuring an off-white background with dark monospace text as a clean minimal inverse of the Terminal_Theme.
- **Reading_Progress_Bar**: A sticky horizontal bar at the top of the Post page that visually indicates how far the User has scrolled through the Post content.
- **Card**: A UI component on the homepage that displays a Post summary including title, cover image, Author avatar, Author name, Tags, and reading time.
- **Tag_Bar**: A horizontal scrollable bar at the top of the feed displaying terminal-style pill buttons for Tag-based filtering.
- **Dashboard**: A personal management interface for Authors to create, edit, publish, and manage their Posts.
- **JWT**: JSON Web Token, the token format used for authenticating Users with the Backend_API.
- **Moderator**: An authenticated User with elevated privileges who can do everything an Author can, plus manage community content (remove Posts and Comments created by other Users) and approve or reject Author_Requests.
- **Rate_Limiter**: A Backend_API middleware component that restricts the number of requests a client can make to specific endpoints within a defined time window.
- **Notification**: A system-generated message informing a User about an event relevant to them, such as a reply to their Comment or a new Comment on their Post.
- **Search_Index**: A queryable index maintained by the Backend_API to support keyword-based full-text search across published Post titles and body content.
- **Slug**: A URL-friendly string derived from a Post's title, used as the unique identifier in Post URLs (e.g., "how-to-build-a-linux-kernel" for a Post titled "How to Build a Linux Kernel"). Slugs consist of lowercase alphanumeric characters and hyphens.
- **Cache**: A temporary data store managed by the Backend_API using Django's cache framework, used to serve frequently requested data (such as homepage Posts and Tag lists) without repeated database queries.
- **Audit_Log**: A structured log record emitted by the Backend_API capturing authentication events, moderation actions, and system errors in JSON format for auditing and diagnostics.
- **Canonical_URL**: A link element in the HTML head of a page that specifies the preferred URL for that page, used to prevent duplicate content issues in search engine indexing.
- **Password_Reset_Token**: A time-limited, single-use token generated by the Backend_API and sent to a User's email address to authorize a password change without requiring the current password.
- **Task_Queue**: An asynchronous task processing system (Celery with Redis as the message broker) used by the Backend_API to execute background jobs such as view event recording and notification creation without blocking API responses.

## Requirements

### Requirement 1: User Registration and Author Approval

**User Story:** As a visitor, I want to register an account on the Platform and request Author status, so that I can participate in the community and eventually publish content after approval.

#### Acceptance Criteria

1. WHEN a visitor submits a registration form with a valid username, email, and password, THE Backend_API SHALL create a new User account with the "User" role (default) and return a JWT access token and a refresh token.
2. WHEN a visitor submits a registration form with an email that already exists, THE Backend_API SHALL return a 409 Conflict response with a descriptive error message.
3. WHEN a visitor submits a registration form with a password shorter than 8 characters, THE Backend_API SHALL return a 400 Bad Request response indicating the password does not meet minimum length requirements.
4. THE Backend_API SHALL hash all User passwords using a secure hashing algorithm before storing them in the database.
5. WHEN a visitor submits a registration form with an invalid email format, THE Backend_API SHALL return a 400 Bad Request response indicating the email format is invalid.
6. WHEN an authenticated User with the "User" role submits an Author_Request, THE Backend_API SHALL create a pending Author_Request and return a confirmation.
7. WHEN a Moderator approves a pending Author_Request, THE Backend_API SHALL promote the requesting User's role to "Author" and create a Notification informing the User of the approval.
8. WHEN a Moderator rejects a pending Author_Request, THE Backend_API SHALL mark the Author_Request as rejected and create a Notification informing the User of the rejection.
9. IF a User who already has the "Author" or "Moderator" role submits an Author_Request, THEN THE Backend_API SHALL return a 409 Conflict response indicating the User already has the requested role or higher.
10. IF a User who has a pending Author_Request submits another Author_Request, THEN THE Backend_API SHALL return a 409 Conflict response indicating a pending request already exists.
11. THE Backend_API SHALL expose an endpoint for Moderators to list all pending Author_Requests.
12. THE Frontend SHALL display an "Request Author Access" button on the Dashboard for authenticated Users with the "User" role, and display the current request status (pending, approved, rejected) when an Author_Request exists.

### Requirement 2: User Authentication

**User Story:** As a registered User, I want to log in and out of the Platform, so that I can securely access my Dashboard and author content.

#### Acceptance Criteria

1. WHEN a User submits valid login credentials (email and password), THE Backend_API SHALL return a JWT access token and a refresh token.
2. WHEN a User submits invalid login credentials, THE Backend_API SHALL return a 401 Unauthorized response with a generic error message that does not reveal whether the email or password was incorrect.
3. WHEN a User sends a request with an expired JWT access token, THE Backend_API SHALL return a 401 Unauthorized response.
4. WHEN a User submits a valid refresh token, THE Backend_API SHALL return a new JWT access token.
5. WHEN a User logs out, THE Backend_API SHALL invalidate the refresh token associated with that session.
6. THE Frontend SHALL store JWT tokens securely and include the access token in the Authorization header of all authenticated API requests.
7. THE Rate_Limiter SHALL restrict the login endpoint to a maximum of 5 requests per minute per client IP address.
8. THE Rate_Limiter SHALL restrict the registration endpoint to a maximum of 3 requests per minute per client IP address.
9. WHEN a client exceeds the rate limit on an authentication endpoint, THE Backend_API SHALL return a 429 Too Many Requests response with a Retry-After header indicating the number of seconds until the limit resets.

### Requirement 3: Author Profiles

**User Story:** As a User, I want to view Author profiles with their bio, social links, and published posts, so that I can learn more about contributors.

#### Acceptance Criteria

1. THE Backend_API SHALL expose a public endpoint that returns an Author's display name, avatar URL, bio, social links, Badges, and a paginated list of published Posts (default page size of 15 Posts per page) for a given Author identifier.
2. WHEN an authenticated Author updates their profile (display name, bio, avatar, social links), THE Backend_API SHALL persist the changes and return the updated profile data.
3. THE Frontend SHALL render the Author Profile Page displaying the Author's bio, social links, Badges, and a grid of their published Posts.
4. WHEN a User requests a profile for an Author identifier that does not exist, THE Backend_API SHALL return a 404 Not Found response.
5. THE Backend_API SHALL support assigning Badges to Authors based on their role (e.g., [MODERATOR]) or achievement (e.g., [TOP CONTRIBUTOR]).

### Requirement 4: Post Creation and Management

**User Story:** As an approved Author, I want to create, edit, and manage my blog posts from a personal Dashboard, so that I can publish content for the community.

#### Acceptance Criteria

1. WHEN an authenticated Author submits a new Post with a title, Markdown body, and at least three Tags, THE Backend_API SHALL create the Post with a status of "draft", generate a unique Slug from the Post title, and return the created Post data including the Slug.
2. WHEN an Author includes a Tag name that does not yet exist in the system, THE Backend_API SHALL create the new Tag automatically and associate it with the Post.
3. IF an authenticated Author submits a new Post with fewer than three Tags, THEN THE Backend_API SHALL return a 400 Bad Request response indicating that a minimum of three Tags is required.
4. WHEN an authenticated Author uploads a cover image file (JPEG, PNG, or WebP, maximum 5 MB), THE Backend_API SHALL store the image and return a URL that the Frontend uses as the Post's cover image.
5. WHEN an authenticated Author updates an existing Post that the Author owns, THE Backend_API SHALL persist the changes and return the updated Post data.
6. WHEN an authenticated Author updates the title of an existing Post, THE Backend_API SHALL regenerate the Slug from the new title and ensure the updated Slug remains unique.
7. WHEN an authenticated Author publishes a draft Post, THE Backend_API SHALL set the Post status to "published" and record the publication timestamp.
8. WHEN an authenticated Author deletes a Post that the Author owns, THE Backend_API SHALL remove the Post and return a 204 No Content response.
9. IF an authenticated Author attempts to modify or delete a Post that the Author does not own, THEN THE Backend_API SHALL return a 403 Forbidden response.
10. THE Dashboard SHALL display a list of the authenticated Author's Posts with their current status (draft or published) and provide controls for editing, publishing, and deleting each Post.
11. THE Backend_API SHALL calculate and return the estimated reading time for each Post based on the word count of the Markdown body.

### Requirement 5: Rich Text Editor with Code Syntax Highlighting

**User Story:** As an Author, I want to write posts using a Markdown editor with live preview and syntax-highlighted code blocks, so that I can create well-formatted technical content.

#### Acceptance Criteria

1. THE Editor SHALL accept Markdown input and render a live preview of the formatted output.
2. THE Editor SHALL support standard Markdown syntax including headings, bold, italic, links, images, blockquotes, ordered lists, unordered lists, and fenced code blocks.
3. WHEN an Author writes a fenced code block with a language identifier, THE Editor SHALL apply syntax highlighting for that language using a terminal-themed color scheme.
4. THE Editor SHALL provide a toolbar with buttons for common Markdown formatting actions (bold, italic, heading, link, image, code block).
5. THE Frontend SHALL serialize the Editor content as a Markdown string for submission to the Backend_API.
6. THE Frontend SHALL parse stored Markdown strings back into rendered HTML for display on the Post page, sanitizing the output to remove any embedded scripts, event handlers, or other executable HTML content.
7. FOR ALL valid Markdown Post content, parsing the Markdown to HTML and then extracting the text content SHALL preserve the original text content of the Post (round-trip text preservation).
8. THE Frontend SHALL sanitize all user-supplied Markdown content during HTML rendering by allowlisting safe HTML tags and attributes and stripping all others.

### Requirement 6: Homepage Post Feed

**User Story:** As a User, I want to browse a visually appealing grid of blog posts on the homepage, so that I can discover interesting content.

#### Acceptance Criteria

1. THE Backend_API SHALL expose a paginated endpoint that returns a list of published Posts ordered by publication date (newest first), with a default page size of 15 Posts per page, including each Post's title, Slug, cover image URL, Author display name, Author avatar URL, Tags, and reading time.
2. THE Frontend SHALL render the homepage as a Pinterest-style Card grid layout using the data from the paginated Posts endpoint.
3. WHEN a User hovers over a Card, THE Frontend SHALL display a glowing border effect on that Card.
4. THE Frontend SHALL apply a green-tinted overlay on each Card's cover image consistent with the Terminal_Theme.
5. WHEN a User scrolls to the bottom of the current page of Cards, THE Frontend SHALL request and render the next page of Posts from the Backend_API.
6. WHILE the Frontend is loading additional Posts, THE Frontend SHALL display a loading indicator.

### Requirement 7: Tag and Category Filtering

**User Story:** As a User, I want to filter posts by tags, so that I can find content relevant to my interests.

#### Acceptance Criteria

1. THE Backend_API SHALL expose an endpoint that returns all Tags that have at least one published Post associated with them.
2. THE Frontend SHALL render the Tag_Bar as a horizontal scrollable bar of terminal-style pill buttons above the post feed.
3. WHEN a User selects a Tag from the Tag_Bar, THE Frontend SHALL request and display only published Posts associated with the selected Tag from the Backend_API.
4. WHEN a User deselects all Tags, THE Frontend SHALL display the full unfiltered post feed.
5. THE Backend_API SHALL support filtering the paginated Posts endpoint by one or more Tag identifiers provided as query parameters.

### Requirement 8: Post Detail Page

**User Story:** As a User, I want to read a full blog post with a clean editorial layout and a reading progress indicator, so that I can comfortably consume technical content.

#### Acceptance Criteria

1. WHEN a User navigates to a Post URL containing a Slug (e.g., /post/how-to-build-a-linux-kernel), THE Frontend SHALL request the Post data from the Backend_API using the Slug and render the full Post content including the title, Author display name, Author avatar, publication date, Tags, reading time, and the Markdown body rendered as HTML.
2. THE Frontend SHALL display the Reading_Progress_Bar as a sticky element at the top of the Post page.
3. WHILE a User scrolls through the Post content, THE Frontend SHALL update the Reading_Progress_Bar to reflect the percentage of Post content scrolled.
4. THE Frontend SHALL render fenced code blocks within the Post as terminal-styled windows with a decorative traffic-light header (three colored circles) and syntax highlighting.
5. WHEN a User navigates to a Post URL containing a Slug that does not correspond to a published Post, THE Frontend SHALL display a 404 Not Found page.
6. THE Frontend SHALL use Slug-based URLs (e.g., /post/{slug}) for all Post links throughout the Platform, including Cards, search results, and Notifications.

### Requirement 9: Comments and Discussions

**User Story:** As a User, I want to comment on posts and reply to other comments, so that I can engage in discussions with the community.

#### Acceptance Criteria

1. WHEN an authenticated User submits a comment on a published Post, THE Backend_API SHALL create the Comment and return the created Comment data including the User's display name, avatar, and timestamp.
2. WHEN an authenticated User submits a reply to an existing Comment, THE Backend_API SHALL create the reply as a child of the parent Comment, supporting one level of threading.
3. WHEN an authenticated User likes a Comment, THE Backend_API SHALL increment the like count for that Comment and record that the User has liked the Comment.
4. IF an authenticated User attempts to like a Comment that the User has already liked, THEN THE Backend_API SHALL return a 409 Conflict response.
5. THE Frontend SHALL render Comments in a threaded layout styled as a terminal chat log, displaying each Comment's author name, avatar, timestamp, content, like count, and reply controls, with replies visually indented under their parent Comment using a left border accent line to indicate nesting.
6. WHEN an authenticated User submits a reply to a Comment, THE Frontend SHALL render the reply indented one level beneath the parent Comment in the terminal chat log, distinguishing replies from top-level Comments.
7. WHEN an unauthenticated User attempts to submit a Comment or like, THE Frontend SHALL prompt the User to log in.
8. THE Backend_API SHALL return Comments for a given Post in chronological order, with replies nested under their parent Comment, with a default page size of 15 Comments per page.
9. WHEN an authenticated User sends a request to delete a Comment that the User owns, THE Backend_API SHALL delete the Comment and return a 204 No Content response.
10. THE Frontend SHALL display a delete control on each Comment owned by the authenticated User.

### Requirement 10: Terminal Theme and Visual Design

**User Story:** As a User, I want the Platform to have a distinctive hacker/terminal aesthetic, so that the visual experience matches the tech community identity.

#### Acceptance Criteria

1. THE Frontend SHALL use deep black (#0d0d0d) and dark gray (#1a1a1a) as the base background colors for the Terminal_Theme.
2. THE Frontend SHALL use neon green (#00ff41) or electric cyan (#00e5ff) as accent colors for interactive elements, borders, and highlights in the Terminal_Theme.
3. THE Frontend SHALL use monospace fonts (JetBrains Mono, Fira Code, or IBM Plex Mono) for headings, UI labels, and code blocks.
4. THE Frontend SHALL use a clean sans-serif font (Inter) for long-form body text to ensure reading comfort.
5. THE Frontend SHALL apply terminal-style borders, bracket-style labels (e.g., [READ MORE], > EXPLORE), and faint grid or dot background textures to UI elements.
6. THE Frontend SHALL display a blinking cursor effect on call-to-action buttons.
7. THE Frontend SHALL use muted white tones for body text in the Terminal_Theme.

### Requirement 11: Dark and Light Mode Toggle

**User Story:** As a User, I want to switch between dark and light modes, so that I can choose the visual style that suits my preference.

#### Acceptance Criteria

1. THE Frontend SHALL default to the Terminal_Theme (dark mode) on first visit.
2. WHEN a User toggles the theme switch, THE Frontend SHALL transition from the Terminal_Theme to the Light_Theme or vice versa.
3. THE Frontend SHALL persist the User's theme preference in local storage and apply the saved preference on subsequent visits.
4. THE Light_Theme SHALL use an off-white background with dark monospace text as a clean minimal inverse of the Terminal_Theme.

### Requirement 12: SEO Optimization

**User Story:** As a platform operator, I want the Platform to be optimized for search engines, so that blog posts are discoverable and rank well in search results.

#### Acceptance Criteria

1. THE Frontend SHALL render Post pages using server-side rendering (SSR) or static site generation (SSG) via Next.js to provide fully rendered HTML to search engine crawlers.
2. THE Frontend SHALL generate dynamic meta tags (title, description) for each Post page based on the Post's title and a summary of the Post content.
3. THE Frontend SHALL include Open Graph meta tags (og:title, og:description, og:image, og:url) on each Post page for social media sharing previews.
4. THE Frontend SHALL generate and serve a sitemap.xml file that includes Slug-based URLs for all published Posts, Author Profile Pages, and Tag filter pages.
5. THE Backend_API SHALL expose an endpoint that returns the data needed to generate the sitemap (list of all published Post Slugs, Author identifiers, and Tag identifiers).
6. THE Frontend SHALL include a Canonical_URL link element in the HTML head of every Post page using the Slug-based URL, and on every Author Profile Page and Tag filter page, pointing to the preferred URL for that page.
7. THE Frontend SHALL serve a robots.txt file that allows search engine crawlers to access all public pages and references the sitemap.xml URL.

### Requirement 13: Database Schema and Local Development

**User Story:** As a developer, I want a well-defined PostgreSQL database schema and a Docker-based local development setup, so that I can develop and test the Platform efficiently.

#### Acceptance Criteria

1. THE Backend_API SHALL use PostgreSQL as the primary data store for all User, Post, Comment, Tag, and Badge data.
2. THE Platform SHALL provide a Docker Compose configuration that provisions a PostgreSQL database instance for local development.
3. THE Backend_API SHALL use Django migrations to manage the database schema, ensuring the schema can be created and updated reproducibly.
4. THE Docker Compose configuration SHALL expose the PostgreSQL instance on a configurable host port.
5. THE Backend_API SHALL read database connection parameters (host, port, database name, username, password) from environment variables.
6. THE Backend_API SHALL provide a Django management command or data migration that seeds the first Moderator account using credentials read from environment variables, resolving the bootstrap problem where no Moderator exists to approve Authors or assign roles.
7. THE Docker Compose configuration SHALL provision a Redis instance for use as both the Cache backend and the Celery message broker.
8. THE Docker Compose configuration SHALL provision a Celery worker service connected to the Redis broker for processing asynchronous tasks (e.g., view event recording, notification creation).

### Requirement 14: Project Architecture and API Design

**User Story:** As a developer, I want a clear project architecture and consistent API design, so that the codebase is maintainable and the Frontend and Backend_API integrate cleanly.

#### Acceptance Criteria

1. THE Backend_API SHALL follow RESTful conventions, using standard HTTP methods (GET, POST, PUT, PATCH, DELETE) and returning appropriate HTTP status codes.
2. THE Backend_API SHALL return all responses in JSON format with a consistent envelope structure containing data and error fields.
3. THE Backend_API SHALL version the API using a URL path prefix (e.g., /api/v1/).
4. THE Frontend SHALL organize components into a modular structure separating pages, shared UI components, hooks, and API client utilities.
5. THE Platform SHALL provide documentation listing the recommended libraries for each major feature area (editor, syntax highlighter, animation, authentication).

### Requirement 15: Security Hardening

**User Story:** As a platform operator, I want the Platform to be protected against common web security threats, so that User data and content remain safe.

#### Acceptance Criteria

1. THE Backend_API SHALL configure CORS to allow requests only from the Frontend's origin domain, rejecting requests from all other origins.
2. THE Backend_API SHALL sanitize all user-submitted text input (Post titles, Comment content, profile fields) by stripping or escaping HTML tags and script content before persisting the data. For Post Markdown body content, THE Backend_API SHALL preserve Markdown syntax characters (including angle brackets in fenced code blocks) and only strip raw HTML script tags and event handler attributes, ensuring that valid Markdown constructs are not corrupted by sanitization.
3. THE Backend_API SHALL set secure HTTP response headers including Content-Security-Policy, X-Content-Type-Options, X-Frame-Options, and Strict-Transport-Security on all responses.
4. WHEN a client submits a request containing input that fails sanitization validation, THE Backend_API SHALL return a 400 Bad Request response with a descriptive error message.
5. THE Backend_API SHALL apply rate limiting to all write endpoints (Post creation, Comment submission, profile updates) at a maximum of 30 requests per minute per authenticated User.

### Requirement 16: Image Uploads

**User Story:** As an Author, I want to upload images for post cover photos and inline content, so that I can include visual media in my posts without relying on external hosting.

#### Acceptance Criteria

1. WHEN an authenticated Author uploads an image file through the Editor or the cover image field, THE Backend_API SHALL accept the file, validate that the file type is JPEG, PNG, or WebP, and store the file in a configured storage backend.
2. WHEN an uploaded image file exceeds 5 MB, THE Backend_API SHALL return a 400 Bad Request response indicating the file size limit.
3. WHEN an image is successfully uploaded, THE Backend_API SHALL return a URL pointing to the stored image that the Frontend can use in Post content or as a cover image.
4. IF an authenticated Author uploads a file with a type other than JPEG, PNG, or WebP, THEN THE Backend_API SHALL return a 400 Bad Request response indicating the allowed file types.
5. THE Backend_API SHALL generate unique filenames for uploaded images to prevent filename collisions.
6. WHEN an Author inserts an image via the Editor toolbar, THE Frontend SHALL upload the image to the Backend_API and insert the returned URL as a Markdown image reference into the Editor content.

### Requirement 17: Roles and Permissions

**User Story:** As a platform operator, I want clearly defined roles with distinct permissions and a Moderator-managed Author approval flow, so that community content quality is maintained and trusted Users can manage the platform.

#### Acceptance Criteria

1. THE Backend_API SHALL support three User roles with a strict permission hierarchy: User (default on registration), Author (requires Moderator approval), and Moderator (assigned via admin endpoint).
2. THE Backend_API SHALL enforce that Users with the "User" role can read published Posts, submit Comments, like Comments, and delete their own Comments, but cannot create, edit, or delete Posts.
3. THE Backend_API SHALL enforce that Users with the "Author" role can perform all "User" actions plus create, edit, publish, and delete their own Posts.
4. THE Backend_API SHALL enforce that Users with the "Moderator" role can perform all "Author" actions plus delete Posts and Comments created by other Users and approve or reject Author_Requests.
5. IF a User with the "User" role attempts to create, edit, or delete a Post, THEN THE Backend_API SHALL return a 403 Forbidden response.
6. WHEN a Moderator sends a request to delete a Post created by another Author, THE Backend_API SHALL delete the Post and return a 204 No Content response.
7. WHEN a Moderator sends a request to delete a Comment created by another User, THE Backend_API SHALL delete the Comment and return a 204 No Content response.
8. IF a User without the Moderator role attempts to delete a Post or Comment that the User does not own, THEN THE Backend_API SHALL return a 403 Forbidden response.
9. THE Backend_API SHALL allow an authenticated User to delete a Comment that the User owns, regardless of the User's role.
10. WHEN a Moderator deletes another User's Post or Comment, THE Backend_API SHALL log the action including the Moderator's identifier, the content identifier, and a timestamp.
11. THE Frontend SHALL display Moderator-specific controls (delete buttons, Author_Request approval/rejection controls) on Posts, Comments, and the Moderator dashboard only when the authenticated User has the Moderator role.
12. THE Backend_API SHALL expose an admin-only endpoint for assigning and revoking the Moderator role for a given User identifier.
13. THE Frontend SHALL hide Post creation and Dashboard management controls from Users who do not have the "Author" or "Moderator" role.

### Requirement 18: Post Search

**User Story:** As a User, I want to search for posts by keyword, so that I can quickly find content on topics I am interested in.

#### Acceptance Criteria

1. THE Backend_API SHALL maintain a Search_Index over the title and body content of all published Posts.
2. WHEN a User submits a search query with one or more keywords, THE Backend_API SHALL return a paginated list of published Posts (default page size of 15 Posts per page) whose title or body content matches the query, ordered by relevance, including each Post's Slug for URL construction.
3. THE Frontend SHALL display a search input field accessible from the site header on all pages.
4. WHEN a User submits a search query through the Frontend, THE Frontend SHALL display the matching Posts in the same Card grid layout used on the homepage.
5. WHEN a search query returns no matching Posts, THE Frontend SHALL display a message indicating no results were found.
6. THE Backend_API SHALL update the Search_Index when a Post is published, updated, or deleted.

### Requirement 19: Notifications

**User Story:** As a User, I want to receive notifications when someone replies to my Comment or comments on my Post, so that I can stay engaged with community discussions.

#### Acceptance Criteria

1. WHEN a User submits a Comment on a Post, THE Backend_API SHALL create a Notification for the Post's Author indicating a new Comment on their Post.
2. WHEN a User submits a reply to a Comment, THE Backend_API SHALL create a Notification for the parent Comment's author indicating a new reply to their Comment.
3. THE Backend_API SHALL expose a paginated endpoint that returns all Notifications for the authenticated User, ordered by creation date (newest first), with a default page size of 15 Notifications per page.
4. WHEN an authenticated User requests their Notifications, THE Backend_API SHALL return each Notification's type, associated Post title, triggering User display name, creation timestamp, and read status.
5. WHEN an authenticated User marks a Notification as read, THE Backend_API SHALL update the Notification's read status.
6. THE Frontend SHALL display a Notification icon in the site header showing the count of unread Notifications for the authenticated User.
7. WHEN a User clicks the Notification icon, THE Frontend SHALL display a dropdown list of recent Notifications with links to the relevant Post or Comment.
8. THE Backend_API SHALL not create a Notification when a User comments on their own Post or replies to their own Comment.
9. THE Platform SHALL support in-app Notifications only in v1; email-based notifications are explicitly out of scope for v1 and may be considered in a future release.

### Requirement 20: Post Slug System

**User Story:** As a User, I want blog post URLs to be human-readable and SEO-friendly, so that I can easily share and identify posts from their URLs.

#### Acceptance Criteria

1. WHEN a Post is created, THE Backend_API SHALL generate a Slug by converting the Post title to lowercase, replacing spaces and special characters with hyphens, and removing non-alphanumeric characters (except hyphens).
2. THE Backend_API SHALL enforce uniqueness of Slugs across all Posts by appending a numeric suffix (e.g., "-2", "-3") when a generated Slug conflicts with an existing Slug.
3. THE Backend_API SHALL expose a GET endpoint that accepts a Slug as a path parameter and returns the corresponding published Post data.
4. WHEN a request is made with a Slug that does not match any published Post, THE Backend_API SHALL return a 404 Not Found response.
5. THE Backend_API SHALL store the Slug as an indexed database column on the Post model to ensure efficient lookup.
6. THE Backend_API SHALL limit Slug length to a maximum of 200 characters, truncating at a word boundary when the generated Slug exceeds this limit.
7. FOR ALL Posts with valid titles, generating a Slug and then retrieving the Post by that Slug SHALL return the original Post data (round-trip property).

### Requirement 21: Caching Strategy

**User Story:** As a platform operator, I want frequently requested data to be cached, so that the Platform serves homepage feeds and tag lists quickly without excessive database load.

#### Acceptance Criteria

1. THE Backend_API SHALL cache the homepage paginated Posts response using Django's cache framework, keyed by page number.
2. THE Backend_API SHALL cache the Tag list endpoint response using Django's cache framework.
3. THE Backend_API SHALL cache tag-filtered paginated Posts responses using Django's cache framework, keyed by the combination of selected Tag identifiers and page number.
4. WHEN a Post is created, updated, published, unpublished, or deleted, THE Backend_API SHALL invalidate all cached homepage Posts responses, all cached tag-filtered Posts responses, and any cached Tag list response.
5. THE Backend_API SHALL NOT cache search results from the Post Search endpoint, as search queries are highly variable and caching would provide low hit rates.
6. THE Backend_API SHALL set Cache-Control HTTP headers on cached endpoint responses to allow the Frontend and intermediary proxies to cache responses for the duration of the configured TTL.
7. THE Backend_API SHALL read the cache TTL value from an environment variable, defaulting to 300 seconds when the variable is not set.
8. THE Backend_API SHALL support configuring the cache backend (e.g., in-memory, Redis) through Django settings without requiring code changes.
9. WHEN the cache is unavailable, THE Backend_API SHALL fall back to serving data directly from the database without returning an error to the client.

### Requirement 22: Audit and System Logging

**User Story:** As a platform operator, I want the Backend_API to log authentication events, moderation actions, and system errors in a structured format, so that I can audit platform activity and diagnose issues.

#### Acceptance Criteria

1. THE Backend_API SHALL log all authentication events including successful logins, logouts, and failed login attempts, recording the User identifier (or attempted email for failures), client IP address, and timestamp.
2. THE Backend_API SHALL log all moderation actions including Post deletions by Moderators, Comment deletions by Moderators, and Author_Request approvals and rejections, recording the Moderator's identifier, the target content or request identifier, and a timestamp.
3. THE Backend_API SHALL log all unhandled exceptions and system errors, recording the error type, error message, request path, and timestamp.
4. THE Backend_API SHALL emit all log entries in a structured JSON format containing at minimum the fields: timestamp, log_level, event_type, and message.
5. THE Backend_API SHALL categorize log entries using standard log levels: DEBUG, INFO, WARNING, ERROR, and CRITICAL.
6. THE Backend_API SHALL log authentication events and moderation actions at the INFO level, and system errors at the ERROR or CRITICAL level.
7. THE Backend_API SHALL read the log output destination (e.g., stdout, file path) from an environment variable, defaulting to stdout when the variable is not set.
8. THE Backend_API SHALL read the minimum log level from an environment variable, defaulting to INFO when the variable is not set.
9. THE Backend_API SHALL not include sensitive data (passwords, JWT tokens, refresh tokens) in any log entry.

### Requirement 23: Password Reset

**User Story:** As a registered User, I want to reset my password if I forget it, so that I can regain access to my account without creating a new one.

#### Acceptance Criteria

1. WHEN a User submits a password reset request with a registered email address, THE Backend_API SHALL generate a time-limited password reset token and send it to the provided email address.
2. WHEN a User submits a password reset request with an email address that does not exist, THE Backend_API SHALL return a 200 OK response identical to a successful request, so as not to reveal whether the email is registered.
3. THE password reset token SHALL expire after 15 minutes from the time of generation.
4. WHEN a User submits a new password along with a valid, non-expired reset token, THE Backend_API SHALL update the User's password, hash it using the same secure hashing algorithm as registration, and invalidate the reset token.
5. WHEN a User submits a new password with an expired or invalid reset token, THE Backend_API SHALL return a 400 Bad Request response indicating the token is invalid or expired.
6. THE Rate_Limiter SHALL restrict the password reset request endpoint to a maximum of 3 requests per 15 minutes per client IP address.
7. THE Frontend SHALL provide a "Forgot Password" link on the login page that navigates to a password reset request form.
8. THE Frontend SHALL provide a password reset form (accessible via the emailed link) that accepts and submits the new password along with the reset token.

### Requirement 24: Account Deletion

**User Story:** As a registered User, I want to delete my account and all associated personal data, so that I can exercise my right to data removal.

#### Acceptance Criteria

1. WHEN an authenticated User requests account deletion, THE Backend_API SHALL permanently delete the User's account, profile data, avatar, and all associated personal information.
2. WHEN an account is deleted, THE Backend_API SHALL anonymize all Posts authored by the deleted User by replacing the Author display name with "[Deleted User]" and removing the Author avatar URL, while preserving the Post content for community continuity.
3. WHEN an account is deleted, THE Backend_API SHALL anonymize all Comments authored by the deleted User by replacing the author display name with "[Deleted User]" and removing the avatar URL, while preserving the Comment content.
4. WHEN an account is deleted, THE Backend_API SHALL delete all Notifications associated with the deleted User.
5. WHEN an account is deleted, THE Backend_API SHALL invalidate all JWT access tokens and refresh tokens associated with the deleted User.
6. THE Backend_API SHALL require the User to confirm account deletion by submitting their current password along with the deletion request.
7. WHEN a User submits an account deletion request with an incorrect password, THE Backend_API SHALL return a 403 Forbidden response.
8. THE Frontend SHALL provide an account deletion option in the User's profile settings, with a confirmation dialog that requires password entry before proceeding.
9. THE Backend_API SHALL log the account deletion event (without personal data) in the Audit_Log for compliance record-keeping.

### Requirement 25: Post View Tracking

**User Story:** As a platform operator, I want to track how many times each Post is viewed, so that I can surface trending content, provide analytics to Authors, and improve homepage ranking.

#### Acceptance Criteria

1. WHEN a User loads a published Post detail page, THE Backend_API SHALL record a view event in a post_view table, storing the Post identifier, viewer IP address (or authenticated User identifier), and timestamp.
2. THE Backend_API SHALL deduplicate view counts by not recording more than one view per IP address (or authenticated User) per Post within a 24-hour window.
3. THE Backend_API SHALL include the total view count in the Post detail API response.
4. THE Backend_API SHALL expose an endpoint that returns the top Posts ranked by view count within a configurable time window (e.g., last 7 days, last 30 days) for use in trending sections.
5. THE Dashboard SHALL display the view count for each of the authenticated Author's published Posts.
6. THE Frontend SHALL display the view count on the Post detail page.
7. THE Backend_API SHALL record view events asynchronously to avoid adding latency to the Post detail page response.
